import asyncio
import logging
import pytz
from datetime import datetime, timedelta
from config import Config
from telegram_client import TelegramClient
from utils.api_client import ApiFootballClient
from data.leagues_config import REGRESSAO_LEAGUES

logger = logging.getLogger(__name__)

class RegressaoMediaModule:
    """M√≥dulo para detectar oportunidades de regress√£o √† m√©dia ap√≥s jogos com poucos gols"""
    
    def __init__(self, telegram_client: TelegramClient, api_client: ApiFootballClient):
        self.telegram_client = telegram_client
        self.api_client = api_client
        # Normalizar chaves para int para evitar problemas de tipo
        self.allowed_leagues = {int(k): v for k, v in REGRESSAO_LEAGUES.items()}
        self.notified_matches = set()
        
        logger.info(f"üìà M√≥dulo Regress√£o inicializado com {len(self.allowed_leagues)} ligas")
        logger.info(f"üîß Tipos de chaves: {set(type(k) for k in self.allowed_leagues.keys())}")
    
    def is_under_15_result(self, match):
        """Detecta Under 1.5 gols"""
        try:
            goals = match.get('goals', {})
            home = goals.get('home', 0) if goals.get('home') is not None else 0
            away = goals.get('away', 0) if goals.get('away') is not None else 0
            return (home + away) < 2
        except Exception as e:
            logger.error(f"Erro ao verificar Under 1.5: {e}")
            return False
    
    def is_exact_0x0_result(self, match):
        """Detecta especificamente 0x0"""
        try:
            goals = match.get('goals', {})
            home = goals.get('home', 0) if goals.get('home') is not None else 0
            away = goals.get('away', 0) if goals.get('away') is not None else 0
            return home == 0 and away == 0
        except Exception as e:
            logger.error(f"Erro ao verificar 0x0: {e}")
            return False
    
    async def check_team_under_15(self, team_id, team_name):
        """Verifica se team vem de Under 1.5/0x0 na rodada anterior"""
        try:
            recent_matches = self.api_client.get_team_recent_matches(team_id, 1)
            if not recent_matches:
                logger.debug(f"üîç {team_name}: Nenhuma partida recente encontrada")
                return False, None
            
            last_match = recent_matches[0]
            is_under_15 = self.is_under_15_result(last_match)
            
            if is_under_15:
                is_0x0 = self.is_exact_0x0_result(last_match)
                goals = last_match.get('goals', {})
                score = f"{goals.get('home', 0)}x{goals.get('away', 0)}"
                
                opponent = (last_match['teams']['away']['name'] 
                           if last_match['teams']['home']['id'] == team_id 
                           else last_match['teams']['home']['name'])
                
                match_date = datetime.fromisoformat(last_match['fixture']['date'].replace('Z', '+00:00'))
                days_ago = (datetime.now(pytz.utc) - match_date).days
                
                logger.debug(f"üîç {team_name}: √öltima partida {score} vs {opponent} ({days_ago}d atr√°s)")
                
                if days_ago <= Config.MAX_LAST_MATCH_AGE_DAYS:
                    logger.debug(f"‚úÖ {team_name}: Qualifica para regress√£o (Under 1.5, {days_ago}d)")
                    return True, {
                        'opponent': opponent,
                        'score': score,
                        'date': match_date.strftime('%d/%m'),
                        'is_0x0': is_0x0,
                        'days_ago': days_ago,
                        'league_name': last_match.get('league', {}).get('name', 'N/A')
                    }
                else:
                    logger.debug(f"‚ùå {team_name}: Partida muito antiga ({days_ago}d > {Config.MAX_LAST_MATCH_AGE_DAYS}d)")
            else:
                logger.debug(f"‚ùå {team_name}: √öltima partida n√£o foi Under 1.5")
            
            return False, None
            
        except Exception as e:
            logger.error(f"‚ùå Erro verificando {team_name}: {e}")
            return False, None
    
    async def execute(self):
        """Executa o monitoramento de regress√£o √† m√©dia"""
        if not Config.REGRESSAO_ENABLED:
            logger.info("üìà M√≥dulo Regress√£o desabilitado na configura√ß√£o")
            return
        
        logger.info("üìà Executando monitoramento de regress√£o √† m√©dia...")
        
        try:
            # Verificar hor√°rio ativo COM DEBUG DETALHADO
            lisbon_tz = pytz.timezone("Europe/Lisbon")
            now_lisbon = datetime.now(lisbon_tz)
            current_hour = now_lisbon.hour
            
            logger.info(f"üïê Hora atual Lisboa: {now_lisbon.strftime('%H:%M')} (hora {current_hour})")
            logger.info(f"üïê Hor√°rio ativo: {Config.REGRESSAO_ACTIVE_HOURS_START}h √†s {Config.REGRESSAO_ACTIVE_HOURS_END}h")
            
            if not (Config.REGRESSAO_ACTIVE_HOURS_START <= current_hour <= Config.REGRESSAO_ACTIVE_HOURS_END):
                logger.info(f"‚è∞ M√ìDULO INATIVO neste hor√°rio ({current_hour}h)")
                # Mensagem de diagn√≥stico tempor√°ria
                message = f"‚è∞ Regress√£o INATIVO √†s {current_hour}h Lisboa (ativo: {Config.REGRESSAO_ACTIVE_HOURS_START}-{Config.REGRESSAO_ACTIVE_HOURS_END}h)"
                await self.telegram_client.send_message(Config.CHAT_ID_REGRESSAO, message)
                return
            
            logger.info("‚úÖ M√≥dulo Regress√£o ATIVO - prosseguindo...")
            
            # Usar estrat√©gia similar ao Elite: UTC + m√∫ltiplos status
            date_str_utc = datetime.utcnow().strftime("%Y-%m-%d")
            today_str_lisbon = now_lisbon.strftime("%Y-%m-%d")
            current_date = now_lisbon.date()
            
            logger.info(f"üìÖ Buscando jogos para {today_str_lisbon} (Lisboa) / {date_str_utc} (UTC)")
            
            all_matches = []
            leagues_checked = 0
            
            for league_id, league_info in self.allowed_leagues.items():
                logger.info(f"üîç Liga: {league_info['name']} (ID: {league_id})")
                
                # Buscar com m√∫ltiplos status como no Elite
                matches_ns = self.api_client.get_fixtures_by_date(date_str_utc, league_id=league_id, status="NS") or []
                matches_tbd = self.api_client.get_fixtures_by_date(date_str_utc, league_id=league_id, status="TBD") or []
                matches = matches_ns + matches_tbd
                
                if matches:
                    all_matches.extend(matches)
                    logger.info(f"üìä {league_info['name']}: NS={len(matches_ns)}, TBD={len(matches_tbd)}, Total={len(matches)}")
                    # Debug: mostrar primeiros jogos
                    for i, match in enumerate(matches[:2]):
                        home = match['teams']['home']['name']
                        away = match['teams']['away']['name']
                        match_time = datetime.fromisoformat(match['fixture']['date'].replace('Z', '+00:00'))
                        logger.info(f"   {i+1}. {home} vs {away} √†s {match_time.astimezone(lisbon_tz).strftime('%H:%M')}")
                else:
                    logger.info(f"üìä {league_info['name']}: 0 jogos encontrados")
                
                leagues_checked += 1
            
            logger.info(f"üìä RESUMO BUSCA: {leagues_checked} ligas, {len(all_matches)} jogos totais")
            
            if not all_matches:
                logger.warning("‚ùå NENHUM JOGO ENCONTRADO")
                message = f"‚ö†Ô∏è Regress√£o: 0 jogos encontrados para {today_str_lisbon} nas {len(self.allowed_leagues)} ligas"
                await self.telegram_client.send_message(Config.CHAT_ID_REGRESSAO, message)
                return
            
            alerts_sent = 0
            games_analyzed = 0
            
            for match in all_matches:
                try:
                    # Verificar status do jogo
                    status = match.get('fixture', {}).get('status', {}).get('short')
                    if status not in ("NS", "TBD"):
                        logger.debug(f"Jogo ignorado - status: {status}")
                        continue
                    
                    fixture_id = match['fixture']['id']
                    home_team = match['teams']['home']['name']
                    away_team = match['teams']['away']['name']
                    home_id = match['teams']['home']['id']
                    away_id = match['teams']['away']['id']
                    league_id = int(match['league']['id'])  # Garantir int
                    
                    league_info = self.allowed_leagues.get(league_id)
                    if not league_info:
                        logger.debug(f"Liga {league_id} n√£o permitida")
                        continue
                    
                    # Verificar se o jogo √© realmente hoje em Lisboa
                    match_datetime = datetime.fromisoformat(match['fixture']['date'].replace('Z', '+00:00'))
                    match_date_lisbon = match_datetime.astimezone(lisbon_tz).date()
                    
                    if match_date_lisbon != current_date:
                        logger.debug(f"Jogo {home_team} vs {away_team} n√£o √© hoje em Lisboa")
                        continue
                    
                    games_analyzed += 1
                    logger.debug(f"üîç Analisando: {home_team} vs {away_team}")
                    
                    # Verificar hist√≥rico dos times
                    home_under, home_info = await self.check_team_under_15(home_id, home_team)
                    away_under, away_info = await self.check_team_under_15(away_id, away_team)
                    
                    logger.debug(f"   {home_team} under 1.5? {home_under}")
                    logger.debug(f"   {away_team} under 1.5? {away_under}")
                    
                    if home_under or away_under:
                        notification_key = f"regressao_{today_str_lisbon}_{fixture_id}"
                        
                        if notification_key not in self.notified_matches:
                            teams_info = ""
                            priority = "NORMAL"
                            
                            if home_under and home_info:
                                indicator = "üî• 0x0" if home_info['is_0x0'] else f"Under 1.5 ({home_info['score']})"
                                teams_info += f"üè† <b>{home_team}</b> vem de <b>{indicator}</b> vs {home_info['opponent']} ({home_info['date']} - {home_info['days_ago']}d)\n"
                                if home_info['is_0x0']:
                                    priority = "M√ÅXIMA"
                            
                            if away_under and away_info:
                                indicator = "üî• 0x0" if away_info['is_0x0'] else f"Under 1.5 ({away_info['score']})"
                                teams_info += f"‚úàÔ∏è <b>{away_team}</b> vem de <b>{indicator}</b> vs {away_info['opponent']} ({away_info['date']} - {away_info['days_ago']}d)\n"
                                if away_info['is_0x0']:
                                    priority = "M√ÅXIMA"
                            
                            confidence = "ALT√çSSIMA" if (home_under and away_under) else ("ALTA" if priority == "M√ÅXIMA" else "M√âDIA")
                            
                            tier_indicator = "‚≠ê" * league_info.get('tier', 1)
                            
                            message = f"""üö® <b>ALERTA REGRESS√ÉO √Ä M√âDIA - PRIORIDADE {priority}</b>

üèÜ <b>{league_info['name']} ({league_info['country']}) {tier_indicator}</b>
‚öΩ <b>{home_team} vs {away_team}</b>

{teams_info}
üìä <b>Confian√ßa:</b> {confidence}
üìà <b>Over 1.5 hist√≥rico da liga:</b> {league_info.get('over_15_percentage', 'N/A')}%
üìâ <b>0x0 hist√≥rico da liga:</b> {league_info.get('0x0_ft_percentage', 'N/A')}%

üí° <b>Teoria:</b> Regress√£o √† m√©dia ap√≥s seca de gols na rodada anterior

üéØ <b>Sugest√µes:</b> 
‚Ä¢ üü¢ Over 1.5 Gols (Principal)
‚Ä¢ üü¢ Over 0.5 Gols (Conservador)
‚Ä¢ üü¢ BTTS (Ambas marcam)

üïê <b>HOJE √†s {match_datetime.astimezone(lisbon_tz).strftime('%H:%M')}</b>
üìÖ <b>{current_date.strftime('%d/%m/%Y')}</b>"""
                            
                            success = await self.telegram_client.send_message(Config.CHAT_ID_REGRESSAO, message)
                            if success:
                                self.notified_matches.add(notification_key)
                                alerts_sent += 1
                                logger.info(f"‚úÖ Regress√£o: {home_team} vs {away_team}")
                        else:
                            logger.debug(f"üîÑ {home_team} vs {away_team} j√° notificado hoje")
                    else:
                        logger.debug(f"‚ùå {home_team} vs {away_team} n√£o atende crit√©rios")
                
                except Exception as e:
                    logger.error(f"‚ùå Erro processando jogo regress√£o: {e}")
                    continue
            
            # Resumo final SEMPRE enviado
            interval_minutes = getattr(Config, 'REGRESSAO_INTERVAL_MINUTES', 30)  # Fallback para 30 min
            summary = f"""üìà <b>Monitoramento Regress√£o Conclu√≠do</b>

üìä Jogos analisados: {games_analyzed}
üîç Ligas verificadas: {leagues_checked}
üö® Alertas enviados: {alerts_sent}
üïê Hor√°rio: {now_lisbon.strftime('%H:%M')} Lisboa
‚è∞ Pr√≥xima verifica√ß√£o: {interval_minutes} min

üîß Configura√ß√£o:
‚Ä¢ Idade m√°xima √∫ltimo jogo: {Config.MAX_LAST_MATCH_AGE_DAYS} dias
‚Ä¢ Hor√°rio ativo: {Config.REGRESSAO_ACTIVE_HOURS_START}-{Config.REGRESSAO_ACTIVE_HOURS_END}h
üìÖ {datetime.utcnow().strftime('%d/%m/%Y %H:%M')} UTC"""
            
            await self.telegram_client.send_message(Config.CHAT_ID_REGRESSAO, summary)
        
        except Exception as e:
            logger.error(f"‚ùå Erro no m√≥dulo regress√£o: {e}")
            await self.telegram_client.send_admin_message(f"Erro m√≥dulo regress√£o: {e}")
        
        logger.info("üìà M√≥dulo Regress√£o conclu√≠do")
